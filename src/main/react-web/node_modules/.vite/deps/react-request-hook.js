import {
  require_axios
} from "./chunk-4O55BTLQ.js";
import {
  require_react
} from "./chunk-J4TOJPAF.js";
import {
  __toESM
} from "./chunk-WWO6H54A.js";

// node_modules/react-request-hook/dist/index.es.js
var import_axios = __toESM(require_axios());
var import_react = __toESM(require_react());
var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = isArray(a), arrB = isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var dateA = a instanceof Date, dateB = b instanceof Date;
    if (dateA != dateB)
      return false;
    if (dateA && dateB)
      return a.getTime() == b.getTime();
    var regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
    if (regexpA != regexpB)
      return false;
    if (regexpA && regexpB)
      return a.toString() == b.toString();
    var keys = keyList(a);
    length = keys.length;
    if (length !== keyList(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!hasProp.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
function request(config, _payload) {
  return config;
}
function createRequestError(error) {
  var data = error.response ? error.response.data : null;
  return {
    data,
    message: error.message,
    code: data && data.code || error.code || error.response && error.response.status,
    isCancel: import_axios.default.isCancel(error)
  };
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var RequestContext = (0, import_react.createContext)(null);
var RequestProvider = RequestContext.Provider;
var RequestConsumer = RequestContext.Consumer;
var MissingProviderError = function(_super) {
  __extends(MissingProviderError2, _super);
  function MissingProviderError2() {
    return _super.call(this, "react-request-hook requires an Axios instance to be passed through context via the <RequestProvider>") || this;
  }
  return MissingProviderError2;
}(Error);
function useRequest(fn) {
  var axiosInstance = (0, import_react.useContext)(RequestContext);
  if (!axiosInstance) {
    throw new MissingProviderError();
  }
  var _a = (0, import_react.useState)([]), sources = _a[0], setSources = _a[1];
  var mountedRef = (0, import_react.useRef)(true);
  var removeCancelToken = function(cancelToken) {
    if (mountedRef.current) {
      setSources(function(prevSources) {
        return prevSources.filter(function(source) {
          return source.token !== cancelToken;
        });
      });
    }
  };
  var callFn = (0, import_react.useRef)(fn);
  (0, import_react.useEffect)(function() {
    callFn.current = fn;
  }, [fn]);
  var request$$1 = (0, import_react.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var config = callFn.current.apply(callFn, args);
    var source = import_axios.default.CancelToken.source();
    var ready = function() {
      setSources(function(prevSources) {
        return prevSources.concat([source]);
      });
      return axiosInstance(__assign({}, config, { cancelToken: source.token })).then(function(response) {
        removeCancelToken(source.token);
        return response.data;
      }).catch(function(error) {
        removeCancelToken(source.token);
        throw createRequestError(error);
      });
    };
    return {
      ready,
      cancel: source.cancel
    };
  }, [axiosInstance]);
  var clear = (0, import_react.useCallback)(function(message) {
    if (sources.length > 0) {
      sources.map(function(source) {
        return source.cancel(message);
      });
      if (mountedRef.current) {
        setSources([]);
      }
    }
  }, [sources]);
  var clearRef = (0, import_react.useRef)(clear);
  (0, import_react.useEffect)(function() {
    clearRef.current = clear;
  });
  (0, import_react.useEffect)(function() {
    return function() {
      clearRef.current();
      mountedRef.current = false;
    };
  }, []);
  return [
    {
      clear: function(message) {
        return clearRef.current(message);
      },
      hasPending: sources.length > 0
    },
    request$$1
  ];
}
var REQUEST_CLEAR_MESSAGE = "A new request has been made before completing the last one";
function getNextState(state, action) {
  return {
    data: action.type === "success" ? action.data : state.data,
    error: action.type === "error" ? action.error : void 0,
    isLoading: action.type === "start" ? true : false
  };
}
function useResource(fn, defaultParams) {
  var _a = useRequest(fn), clear = _a[0].clear, createRequest = _a[1];
  var _b = (0, import_react.useReducer)(getNextState, {
    isLoading: Boolean(defaultParams)
  }), state = _b[0], dispatch = _b[1];
  var _c = (0, import_react.useState)(defaultParams), requestParams = _c[0], setRequestParams = _c[1];
  var request2 = (0, import_react.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    clear(REQUEST_CLEAR_MESSAGE);
    var _a2 = createRequest.apply(void 0, args), ready = _a2.ready, cancel = _a2.cancel;
    (function flow() {
      return __awaiter(this, void 0, void 0, function() {
        var data, error_1;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              _a3.trys.push([0, 2, , 3]);
              dispatch({ type: "start" });
              return [4, ready()];
            case 1:
              data = _a3.sent();
              dispatch({ type: "success", data });
              return [3, 3];
            case 2:
              error_1 = _a3.sent();
              if (!error_1.isCancel)
                dispatch({ type: "error", error: error_1 });
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    })();
    return cancel;
  }, [createRequest]);
  (0, import_react.useEffect)(function() {
    if (!defaultParams)
      return;
    setRequestParams(function(current) {
      return fastDeepEqual(current, defaultParams) ? current : defaultParams;
    });
  }, defaultParams);
  (0, import_react.useEffect)(function() {
    var canceller = function() {
    };
    if (requestParams) {
      canceller = request2.apply(void 0, requestParams);
    }
    return canceller;
  }, [requestParams]);
  return (0, import_react.useMemo)(function() {
    var cancel = function(message) {
      dispatch({ type: "reset" });
      clear(message);
    };
    var result = [__assign({}, state, { cancel }), request2];
    return result;
  }, [state, request2]);
}
export {
  RequestConsumer,
  RequestContext,
  RequestProvider,
  createRequestError,
  fastDeepEqual as isEqual,
  request,
  useRequest,
  useResource
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
//# sourceMappingURL=react-request-hook.js.map
